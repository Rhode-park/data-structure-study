# 재귀함수

### 재귀함수의 특징
- 코드길이가 짧다
- 가독성이 좋다
- 메모리가 스택에만 저장된다
- 속도가 느리다
- 메모리가 스택에 저장되므로 무한재귀함수를 돌렸을 때 스택오버플로우 오류가 뜰 수 있다 => 메모리 구조를 보면 스택의 메모리 공간은 작고 함수를 불러오는 콜스택이 누적되면서 오류가 발생하는 것이다!

> 콜스택(call stack) 이란, 함수를 호출할 때 하나씩의 스택 블록이 쌓이게 되는 것을 뜻한다. 함수 호출이 많아질 수록 스택의 메모리 공간을 많이 차지하게 된다

### 올바른 재귀함수 사용법
- base case : 재귀를 끝내는 함수! 만약 이게 없다면 무한 반복되기 때문에 스택오버플로우 오류 발생
- recursive case : 함수 내에서 불려지는 재귀 함수

```swift
func factorial(number: Int) -> Int {

    //base case : 재귀를 끝내는 함수
    if number == 0 {
        return 1
    }
    // recursive case : 함수 내에서 불려지는 재귀 함수
    return number * factorial(number: number - 1)
}

let result = factorial(number: 6)
print(result) // 720
```
- 6이란 값이 입력되었을 때, 0이 되기 전까지 6 * 5 * 4 * 3 * 2 * 1 이 실행되고 0이 되면 return 1 을 하고 * 1이 되고 종료되므로 출력하면 720 나온다.
- 재귀함수는 n-1 만큼 반복한다고 생각할 수 있고 따라서 시간복잡도는 O(n-1)이지만 상수는 제외하면 O(n)이다.

**제곱함수**
```swift
func power(number: Int, n: Int) -> Int {

    // base case
    if n == 0 {
        return 1
    } else {
        return number * power(number: number, n: n - 1 )
    }
}

print(power(number: 2, n: 3))
```
- 2^3 = 2 * 2 * 2 = 8 결과를 확인할 수 있다.
- 쉽게 이해하기 위해 메모리 구조를 생각해 보면 stack과 같이 값이 쌓이고 마지막 값부터 순차적으로 재귀 함수가 돌아가게 된다.
```
 stack
 2 * power(2,2) // 4 = 8
 2 * power(2,1) // 2 = 4
 2 * power(2,0) // 1 = 2
 1
```

<img src="https://i.imgur.com/0P6Q6PO.png" width ="500">


## 꼬리재귀함수
- 스택에 쌓이는 형태가 아니라 지속적으로 값을 리턴하면서 메모리를 효율적으로 사용하는 방법

```swift
func TailFactorial(n: Int, answer: Int = 1) -> Int {
    if n == 1 { return answer }
    
    return TailFactorial(n: n-1, answer: answer * n)
}

TailFactorial(n: 5)    // 120
```

[컴파일최적화-꼬리재귀함수](https://serynana.tistory.com/entry/iOS-%EC%BB%B4%ED%8C%8C%EC%9D%BC-%EC%B5%9C%EC%A0%81%ED%99%94-feat-%EA%BC%AC%EB%A6%AC%EC%9E%AC%EA%B7%80)


## 트램폴린
- 함수를 호출하고 그 결과를 통해 다시 그 함수를 호출하는 식으로 트램폴린 처럼 점프하는 것을 의미!

[참고블로그](https://soooprmx.com/꼬리재귀-최적화와-트램폴린/)
(생소한 개념이라 추가 공부가 더 필요하다...🤯)


---
## 참고
[개발자소들이](https://babbab2.tistory.com/99)
